/**
 * File: DHCP_Protocol_Analyzer.py
 * Author: Amey Thakur
 * GitHub: [Amey-Thakur](https://github.com/Amey-Thakur)
 * Repository: [COMPUTER-NETWORKS](https://github.com/Amey-Thakur/COMPUTER-NETWORKS)
 * Session: Fall 2023
 * Release Date: November 01, 2023
 * License: Creative Commons Attribution 4.0 International (CC BY 4.0)
 * 
 * Description:
 * This script serves as a technical companion to Lab 04: Dynamic Host Configuration Protocol (DHCP).
 * It explores the four-step "DORA" process (Discover, Offer, Request, Acknowledge) used for 
 * dynamic IP address allocation. It also demonstrates the use of Transaction IDs and 
 * UDP-based transport.
 */

import random

class DHCPSystemArchive:
    """
    A collection of utilities to illustrate DHCP allocation and protocol mechanics.
    """

    def __init__(self):
        # Data derived from the Lab 4 trace analysis
        self.server_ip = "192.168.2.1"
        self.client_mac = "1c:4d:70:a6:0b:49"
        self.lease_time = 259200  # 3 days in seconds
        self.ports = {"Server": 67, "Client": 68}

    def simulate_dora_process(self):
        """
        Simulates the Discover, Offer, Request, and ACK sequence.
        Reflects Question 2, 5, and 6 of the lab report.
        """
        transaction_id = "0x74292a0" # Constant for a single transaction set
        
        print("\n" + "="*70)
        print(f"SIMULATING DHCP DORA PROCESS (TRANS-ID: {transaction_id})")
        print("="*70)

        # 1. DISCOVER
        print(f"[STAGE 1: DISCOVER] Client ({self.client_mac}) -> 255.255.255.255")
        print(f"    - IP: 0.0.0.0 -> 255.255.255.255 | UDP Port: {self.ports['Client']}->{self.ports['Server']}")
        print(f"    - Option 53: 1 (Discover)")

        # 2. OFFER
        offered_ip = "192.168.2.95"
        print(f"\n[STAGE 2: OFFER] Server ({self.server_ip}) -> 255.255.255.255")
        print(f"    - IP: {self.server_ip} -> 255.255.255.255")
        print(f"    - Offered Address: {offered_ip} | Lease: {self.lease_time}s")

        # 3. REQUEST
        print(f"\n[STAGE 3: REQUEST] Client -> 255.255.255.255")
        print(f"    - Requesting IP: {offered_ip}")
        print(f"    - Option 53: 3 (Request)")

        # 4. ACK
        print(f"\n[STAGE 4: ACK] Server -> 255.255.255.255")
        print(f"    - Acknowledging Allocation of {offered_ip}")
        print("="*70)

    @staticmethod
    def explain_transaction_id():
        """
        Explains the purpose of the Transaction-ID as explored in Question 5.
        """
        print("\n" + "-"*60)
        print("TECHNICAL INSIGHT: THE TRANSACTION ID (XID)")
        print("-"*60)
        print("The Transaction ID is a unique 32-bit identifier generated by")
        print("the client. It is used to match DHCP requests with server")
        print("responses, ensuring that even in complex network environments,")
        print("the client correctly identifies messages intended for its")
        print("specific allocation handshake.")
        print("-"*60)

def main():
    print("="*70)
    print("SCHOLARLY ANALYSIS: DYNAMIC HOST CONFIGURATION PROTOCOL (DHCP)")
    print("="*70)

    archive = DHCPSystemArchive()

    # 1. Execute the DORA simulation
    archive.simulate_dora_process()

    # 2. Provide protocol insights
    archive.explain_transaction_id()

    # 3. Scholarly Insight
    print("\n" + "="*70)
    print("SCHOLARLY INSIGHT & NETWORKING TIP")
    print("="*70)
    print("DHCP operates over UDP because at the start of the process, the")
    print("client does not yet have an IP address to establish a TCP session.")
    print("By using broadcast addresses and simple UDP datagrams, the client")
    print("can discover local servers without prior configuration. This")
    print("'Zero Configuration' capability is fundamental to the scalability")
    print("of modern IP networks.")
    print("="*70)

if __name__ == "__main__":
    main()
